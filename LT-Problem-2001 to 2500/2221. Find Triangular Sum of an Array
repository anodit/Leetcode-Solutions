‚ùì Question

You are given a 0-indexed integer array nums, where nums.length == n.
You must perform the following operation until nums becomes a single element:

For each index i from 0 to n-2:
Replace nums[i] with (nums[i] + nums[i+1]) % 10.

After performing the operation n-1 times, only one element remains.
Return that element.

Example 1:

Input: nums = [1,2,3,4,5]
Output: 8


Example 2:

Input: nums = [5]
Output: 5


Constraints:

1 <= nums.length <= 1000

0 <= nums[i] <= 9

üíª Solution(s)
üê¢ Brute Force (Simulation ‚Äì O(n¬≤))
class Solution {
    public int triangularSum(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                nums[j] = (nums[j] + nums[j + 1]) % 10;
            }
        }
        return nums[0];
    }
}

üìê Math Approach (Binomial Coefficients ‚Äì O(n¬≤))

Using the identity:

ùëé
ùëõ
ùë†
=
‚àë
ùëñ
=
0
ùëõ
‚àí
1
(
ùëõ
‚àí
1
ùëñ
)
‚ãÖ
ùëõ
ùë¢
ùëö
ùë†
[
ùëñ
]
(
m
o
d
10
)
ans=
i=0
‚àë
n‚àí1
	‚Äã

(
i
n‚àí1
	‚Äã

)‚ãÖnums[i](mod10)
class Solution {
    public int triangularSum(int[] nums) {
        int n = nums.length;
        int[] coeff = new int[n];
        coeff[0] = 1;
        for (int r = 1; r <= n - 1; r++) {
            for (int i = r; i >= 1; i--) {
                coeff[i] = (coeff[i] + coeff[i - 1]) % 10;
            }
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans = (ans + coeff[i] * nums[i]) % 10;
        }
        return ans;
    }
}

‚ö° Optimized Math (Binomial via Multiplicative Formula ‚Äì O(n))
import java.math.BigInteger;

class Solution {
    public int triangularSum(int[] nums) {
        int n = nums.length;
        BigInteger coeff = BigInteger.ONE;
        BigInteger mod = BigInteger.TEN;
        BigInteger result = BigInteger.ZERO;

        for (int i = 0; i < n; i++) {
            result = result.add(coeff.multiply(BigInteger.valueOf(nums[i]))).mod(mod);
            if (i < n - 1) {
                coeff = coeff.multiply(BigInteger.valueOf(n - 1 - i))
                             .divide(BigInteger.valueOf(i + 1));
            }
        }
        return result.intValue();
    }
}

üõ†Ô∏è Approach

Simulation way ‚Üí Shrink array step by step until one number remains.

Math way ‚Üí Notice the last number is actually a combination of binomial coefficients √ó nums[i] (mod 10).

Use either Pascal‚Äôs triangle or direct formula to compute.

üí° Intuition

Every step is like building the Pascal‚Äôs Triangle üî∫ (each number formed by adding two above it).

Final number is simply the binomial expansion of coefficients multiplied by the original array.

That‚Äôs why math shortcut works faster ‚ö°.