# ğŸ“Œ Question

Given an integer array `nums`, move all `0`s to the end **in-place** while keeping the relative order of non-zero elements.
âš¡ No extra copy of the array allowed.

**Example 1**:
Input â†’ `[0,1,0,3,12]`
Output â†’ `[1,3,12,0,0]`

**Example 2**:
Input â†’ `[0]`
Output â†’ `[0]`

---

# ğŸ§  Intuition

* We want **non-zero numbers first** â¡ï¸ in their original order.
* Push all **zeroes at the end**.
* Must do this **in-place** (no extra array).

Think of it like **compressing** all useful items (non-zeros) to the front, and then just filling the empty space with 0â€™s.

---

# ğŸ› ï¸ Approaches

## 1ï¸âƒ£ Brute Force (Not Good âŒ)

* Create a **new array**, copy non-zero elements, then add zeros at the end.
* But âŒ this breaks the â€œin-placeâ€ rule.

---

## 2ï¸âƒ£ Two-Pass Method (âœ… Simple & Clean)

ğŸ‘‰ **Step 1**: Move all non-zero numbers to the front.
ğŸ‘‰ **Step 2**: Fill the remaining positions with `0`.

### Java Code

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int insertPos = 0; // index to place next non-zero element
        
        // Step 1: Shift all non-zero numbers forward
        for (int num : nums) {
            if (num != 0) {
                nums[insertPos++] = num;
            }
        }
        
        // Step 2: Fill remaining positions with zeros
        while (insertPos < nums.length) {
            nums[insertPos++] = 0;
        }
    }
}
```

âœ… Time: O(n)
âœ… Space: O(1)

---

## 3ï¸âƒ£ One-Pass Method (âš¡ More Optimized: Min Ops)

ğŸ‘‰ Use **two pointers** (`left` = position for next non-zero, `right` = scanning).
ğŸ‘‰ Whenever we see a non-zero, **swap** with `left`.

### Java Code

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0; // position for next non-zero
        
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] != 0) {
                // Swap nums[left] and nums[right]
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
            }
        }
    }
}
```

âœ… Time: O(n)
âœ… Space: O(1)
âœ… Minimizes operations â€” only swaps when needed ğŸ¯

---

# ğŸ¯ Follow-Up (Minimizing Ops)

* **Two-Pass** writes all numbers twice (first pass + filling zeros).
* **One-Pass Swap** only writes/swaps when necessary.
* So âš¡ **One-Pass Swap Method is optimal**.

---

# âœ¨ Final Summary

* **Brute Force** â†’ âŒ Extra space (not allowed).
* **Two-Pass** â†’ âœ… Easy, but may do extra writes.
* **One-Pass Swap** â†’ âœ…âš¡ Best, minimal operations, in-place.

---

ğŸ‘‰ Recommended for interviews: Explain **both Two-Pass & One-Pass**, then say **One-Pass is optimal**.

---