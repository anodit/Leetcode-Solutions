Got it bhai üòé ‚Äî main tumhe **complete solution file** deta hoon in the exact format tumne pehle bola tha:

* **Question** (from LeetCode)
* **Solution(s)** (Java brute force ‚Üí optimal)
* **Approach**
* **Intuition**
* **Dry Run (animated style)**

---

# üìÑ Question

**122. Best Time to Buy and Sell Stock II**

You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `i·µó ∞` day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.

Find and return the **maximum profit** you can achieve.

---

## Example 1

Input: `prices = [7,1,5,3,6,4]`
Output: `7`
Explanation: Buy at 1 ‚Üí sell at 5 (profit = 4), buy at 3 ‚Üí sell at 6 (profit = 3). Total = 7.

## Example 2

Input: `prices = [1,2,3,4,5]`
Output: `4`
Explanation: Buy at 1 ‚Üí sell at 5 (profit = 4).

## Example 3

Input: `prices = [7,6,4,3,1]`
Output: `0`
Explanation: No profitable transactions possible.

---

## ‚ö° Constraints

* `1 <= prices.length <= 3 * 10^4`
* `0 <= prices[i] <= 10^4`

---

# üí° Intuition

Here we are allowed **multiple transactions** ‚úÖ (unlike Problem 121).
So, the best strategy is:

* **Collect profit from every upward slope**.
* Whenever `prices[i+1] > prices[i]`, add `(prices[i+1] - prices[i])` to profit.
* This works because buying at valley & selling at peak = same as summing all intermediate rises.

---

# üß† Approach

1. Traverse the prices array.
2. For each consecutive pair `(prices[i], prices[i+1])`:

   * If `prices[i+1] > prices[i]`, add `(prices[i+1] - prices[i])` to profit.
   * Otherwise, skip (no gain possible).
3. Return total profit.

---

# üõ†Ô∏è Solution(s)

### ‚úÖ Greedy (Optimal, O(n))

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            if (prices[i + 1] > prices[i]) {
                profit += prices[i + 1] - prices[i]; // collect every rise
            }
        }
        return profit;
    }
}
```

* **Time Complexity:** O(n) ‚Üí single pass
* **Space Complexity:** O(1) ‚Üí constant extra space

---

### üßæ Alternative (DP style ‚Äì for extensions like fees/cooldown)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int cash = 0;              // max profit when not holding
        int hold = -prices[0];     // max profit when holding

        for (int i = 1; i < prices.length; i++) {
            int prevCash = cash;
            cash = Math.max(cash, hold + prices[i]);  // sell today
            hold = Math.max(hold, prevCash - prices[i]); // buy today
        }
        return cash;
    }
}
```

Same result but useful for advanced variants.

---

# üé¨ Dry Run ‚Äî Greedy Approach

### Example: `prices = [7,1,5,3,6,4]`

```
i=0: 1-7 = -6 ‚Üí ignore ‚ùå
profit = 0

i=1: 5-1 = +4 ‚Üí take ‚úÖ
profit = 4

i=2: 3-5 = -2 ‚Üí ignore ‚ùå
profit = 4

i=3: 6-3 = +3 ‚Üí take ‚úÖ
profit = 7

i=4: 4-6 = -2 ‚Üí ignore ‚ùå
profit = 7
```

üëâ Final Answer = **7** ‚úÖ

---

# ‚úÖ Summary

* If unlimited transactions allowed ‚Üí **sum all positive differences** between consecutive days.
* Greedy solution is **O(n)** and optimal.
* DP solution is also valid, especially useful if problem changes (transaction fees, cooldown, etc.).

---