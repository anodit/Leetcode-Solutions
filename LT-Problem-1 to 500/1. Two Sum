📝 Question

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution.

You may not use the same element twice.

You can return the answer in any order.

Example 1

Input: nums = [2,7,11,15], target = 9  
Output: [0,1]  
Explanation: Because nums[0] + nums[1] == 9, we return [0,1].


Example 2

Input: nums = [3,2,4], target = 6  
Output: [1,2]


Example 3

Input: nums = [3,3], target = 6  
Output: [0,1]


Constraints

2 <= nums.length <= 10⁴

-10⁹ <= nums[i] <= 10⁹

-10⁹ <= target <= 10⁹

Only one valid answer exists

💻 Solution (Optimized using HashMap)
import java.util.*;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        
        for(int i = 0; i < nums.length; i++) {
            int secondNumber = target - nums[i];
            
            if(map.containsKey(secondNumber)) {
                // Found the pair
                return new int[]{ i, map.get(secondNumber) };
            }
            
            // Store current number with its index
            map.put(nums[i], i);
        }
        
        // Default (should never hit because one solution always exists)
        return new int[]{0, 1};
    }
}

🧠 Approach

Create a HashMap to store numbers and their indices.

Loop through each element nums[i].

Compute secondNumber = target - nums[i].

If secondNumber is already in the map → return indices [i, map.get(secondNumber)].

Else, store nums[i] in the map with index i.

Since only one solution exists, the loop will always return before finishing.

💡 Intuition

The problem is asking us to find two numbers that sum up to a target.

Instead of checking every possible pair (O(n²) brute force), we can store numbers we’ve seen in a map.

This way, for every number, we instantly know if its complement exists (in O(1) lookup).

This reduces the time complexity to O(n).