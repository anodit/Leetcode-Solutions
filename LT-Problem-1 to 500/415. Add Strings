â“ Question

Given two non-negative integers, num1 and num2 represented as strings, return the sum of num1 and num2 as a string.

You must solve the problem without using any built-in library for handling large integers (such as BigInteger) or directly converting the inputs to integers.

Example 1:

Input:

num1 = "11", num2 = "123"


Output:

"134"

Example 2:

Input:

num1 = "456", num2 = "77"


Output:

"533"

Example 3:

Input:

num1 = "0", num2 = "0"


Output:

"0"


Constraints:

1 <= num1.length, num2.length <= 10^4

num1 and num2 consist only of digits.

num1 and num2 do not contain any leading zeros except the number "0".

ğŸ’¡ Intuition

The task is basically manual addition like on paper âœï¸.

Start from the last digit of both strings.

Add them along with any carry.

Append the result to a builder.

Continue until both strings and carry are processed.

Reverse at the end (since we build result from back to front).

This avoids integer overflow and keeps the logic simple.

ğŸ› ï¸ Approach

Use two pointers (i for num1, j for num2) starting from the last index.

Keep a carry variable initialized to 0.

At each step:

Take digit from num1 (if exists) else 0.

Take digit from num2 (if exists) else 0.

Compute sum = d1 + d2 + carry.

Append sum % 10 to result.

Update carry = sum / 10.

After loop, if carry > 0, append it.

Reverse the result string and return.

ğŸ’» Solution(s)
âœ… Brute Force (Not recommended but intuitive)

Convert strings digit by digit to integer.

Add integers.

Convert back to string.
âŒ Fails for very large numbers (overflow).

ğŸš€ Optimal Solution (Two-pointer + Carry)
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder sb = new StringBuilder();
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        int carry = 0;

        while (i >= 0 || j >= 0 || carry > 0) {
            int d1 = (i >= 0) ? num1.charAt(i) - '0' : 0;
            int d2 = (j >= 0) ? num2.charAt(j) - '0' : 0;

            int sum = d1 + d2 + carry;
            sb.append(sum % 10);
            carry = sum / 10;

            i--;
            j--;
        }

        return sb.reverse().toString();
    }
}


âœ… Time Complexity â†’ O(max(n, m)) (we iterate through both strings once).
âœ… Space Complexity â†’ O(max(n, m)) (for the StringBuilder result).