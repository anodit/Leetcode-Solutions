# 🔢 Problem Statement

You’re given an array of digits 📊 where each element is a digit of a large number (most significant digit first, no leading zeros).
👉 Task: Increment the number by **1** and return the result as a new array.

### ✅ Examples

* **Input:** \[1,2,3] → **Output:** \[1,2,4]
* **Input:** \[4,3,2,1] → **Output:** \[4,3,2,2]
* **Input:** \[9] → **Output:** \[1,0]

---

# 💡 Intuition

Think of this problem like **adding 1 with carry** (just like we do in math 🧮 on paper).

* Start from the **last digit** ➡️ add 1.
* If it becomes **10**, turn it into `0` and **carry over 1** to the next digit.
* Repeat until no carry is left.
* If after the loop there’s still a carry (like when all digits are `9`), then add a new `1` at the front.

Example:
`[9,9,9]` → Add 1 → `[0,0,0]` with carry → Final `[1,0,0,0]`. 🎉

---

# 🛠️ Approach

1. Traverse from the last digit 🔙.
2. Add **1**.
3. If digit < 10 → return result ✅.
4. Else, set digit = 0 and continue carry.
5. If loop ends and still carry remains → prepend `1`.

---

# 💻 Solutions in Java

### 1️⃣ Brute Force (Convert to Number) ❌ (not safe for very large numbers)

```java
class Solution {
    public int[] plusOne(int[] digits) {
        StringBuilder sb = new StringBuilder();
        for (int digit : digits) {
            sb.append(digit);
        }
        java.math.BigInteger num = new java.math.BigInteger(sb.toString());
        num = num.add(BigInteger.ONE);
        String result = num.toString();
        int[] ans = new int[result.length()];
        for (int i = 0; i < result.length(); i++) {
            ans[i] = result.charAt(i) - '0';
        }
        return ans;
    }
}
```

⚠️ Works but inefficient for interviews — relies on BigInteger.

---

### 2️⃣ Optimal Approach (Digit by Digit Simulation)

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
        
        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] < 9) {   // no carry needed
                digits[i]++;
                return digits;
            }
            digits[i] = 0;  // reset to 0 and carry over
        }
        
        // If all digits were 9 (like [9,9,9])
        int[] result = new int[n + 1];
        result[0] = 1;
        return result;
    }
}
```

⏱️ **Time Complexity:** O(n)
📦 **Space Complexity:** O(1) (or O(n) in case we need new array).

---

# 🔍 Example Walkthrough

### Input: \[4,3,9]

* Start from last → `9 + 1 = 10` → make it `0`, carry = 1.
* Next → `3 + 1 = 4` → no carry.
* Final: `[4,4,0]` ✅

### Input: \[9,9,9]

* Last → becomes `0`, carry continues.
* Next → becomes `0`, carry continues.
* Next → becomes `0`, carry continues.
* Add new digit at front → `[1,0,0,0]` ✅

---

# 🎯 Final Thoughts

👉 This problem is basically **manual addition with carry**.
👉 Brute force is okay for practice, but **optimal O(n)** digit simulation is the **real interview answer**.

---