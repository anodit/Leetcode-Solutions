# ğŸ”¢ Problem Statement

Youâ€™re given an array of digits ğŸ“Š where each element is a digit of a large number (most significant digit first, no leading zeros).
ğŸ‘‰ Task: Increment the number by **1** and return the result as a new array.

### âœ… Examples

* **Input:** \[1,2,3] â†’ **Output:** \[1,2,4]
* **Input:** \[4,3,2,1] â†’ **Output:** \[4,3,2,2]
* **Input:** \[9] â†’ **Output:** \[1,0]

---

# ğŸ’¡ Intuition

Think of this problem like **adding 1 with carry** (just like we do in math ğŸ§® on paper).

* Start from the **last digit** â¡ï¸ add 1.
* If it becomes **10**, turn it into `0` and **carry over 1** to the next digit.
* Repeat until no carry is left.
* If after the loop thereâ€™s still a carry (like when all digits are `9`), then add a new `1` at the front.

Example:
`[9,9,9]` â†’ Add 1 â†’ `[0,0,0]` with carry â†’ Final `[1,0,0,0]`. ğŸ‰

---

# ğŸ› ï¸ Approach

1. Traverse from the last digit ğŸ”™.
2. Add **1**.
3. If digit < 10 â†’ return result âœ….
4. Else, set digit = 0 and continue carry.
5. If loop ends and still carry remains â†’ prepend `1`.

---

# ğŸ’» Solutions in Java

### 1ï¸âƒ£ Brute Force (Convert to Number) âŒ (not safe for very large numbers)

```java
class Solution {
    public int[] plusOne(int[] digits) {
        StringBuilder sb = new StringBuilder();
        for (int digit : digits) {
            sb.append(digit);
        }
        java.math.BigInteger num = new java.math.BigInteger(sb.toString());
        num = num.add(BigInteger.ONE);
        String result = num.toString();
        int[] ans = new int[result.length()];
        for (int i = 0; i < result.length(); i++) {
            ans[i] = result.charAt(i) - '0';
        }
        return ans;
    }
}
```

âš ï¸ Works but inefficient for interviews â€” relies on BigInteger.

---

### 2ï¸âƒ£ Optimal Approach (Digit by Digit Simulation)

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
        
        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] < 9) {   // no carry needed
                digits[i]++;
                return digits;
            }
            digits[i] = 0;  // reset to 0 and carry over
        }
        
        // If all digits were 9 (like [9,9,9])
        int[] result = new int[n + 1];
        result[0] = 1;
        return result;
    }
}
```

â±ï¸ **Time Complexity:** O(n)
ğŸ“¦ **Space Complexity:** O(1) (or O(n) in case we need new array).

---

# ğŸ” Example Walkthrough

### Input: \[4,3,9]

* Start from last â†’ `9 + 1 = 10` â†’ make it `0`, carry = 1.
* Next â†’ `3 + 1 = 4` â†’ no carry.
* Final: `[4,4,0]` âœ…

### Input: \[9,9,9]

* Last â†’ becomes `0`, carry continues.
* Next â†’ becomes `0`, carry continues.
* Next â†’ becomes `0`, carry continues.
* Add new digit at front â†’ `[1,0,0,0]` âœ…

---

# ğŸ¯ Final Thoughts

ğŸ‘‰ This problem is basically **manual addition with carry**.
ğŸ‘‰ Brute force is okay for practice, but **optimal O(n)** digit simulation is the **real interview answer**.

---