### **Question â“**

Given two integer arrays `nums1` and `nums2`, return an array of their **intersection**.
Each element in the result must be **unique ğŸŸ¢** and you may return the result in any order.

**Example 1:**
ğŸ‘‰ Input: nums1 = \[1,2,2,1], nums2 = \[2,2]
âœ… Output: \[2]

**Example 2:**
ğŸ‘‰ Input: nums1 = \[4,9,5], nums2 = \[9,4,9,8,4]
âœ… Output: \[9,4]
ğŸ“Œ Explanation: \[4,9] is also accepted.

**Constraints:**

* 1 <= nums1.length, nums2.length <= 1000
* 0 <= nums1\[i], nums2\[i] <= 1000

---

### **Solution(s) ğŸ’¡**

#### ğŸ”´ Solution 1 â€” Brute Force (Naive)

```java
public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        java.util.Set<Integer> set = new java.util.HashSet<>();
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < nums2.length; j++) {
                if (nums1[i] == nums2[j]) {
                    set.add(nums1[i]);
                    break;
                }
            }
        }
        int[] res = new int[set.size()];
        int idx = 0;
        for (int v : set) res[idx++] = v;
        return res;
    }
}
```

â± **Time Complexity:** O(mÂ·n)
ğŸ’¾ **Space Complexity:** O(min(m,n))

---

#### ğŸŸ¡ Solution 2 â€” HashSet (Recommended âœ…)

```java
import java.util.HashSet;
import java.util.Set;

public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        for (int n : nums1) set1.add(n);

        Set<Integer> resultSet = new HashSet<>();
        for (int n : nums2) {
            if (set1.contains(n)) resultSet.add(n);
        }

        int[] res = new int[resultSet.size()];
        int i = 0;
        for (int v : resultSet) res[i++] = v;
        return res;
    }
}
```

â± **Time Complexity:** O(m + n)
ğŸ’¾ **Space Complexity:** O(min(m,n))

---

#### ğŸ”µ Solution 3 â€” Sorting + Two Pointers ğŸ“Š

```java
import java.util.Arrays;
import java.util.ArrayList;

public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        ArrayList<Integer> list = new ArrayList<>();
        int i = 0, j = 0;
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] == nums2[j]) {
                if (list.isEmpty() || list.get(list.size() - 1) != nums1[i]) {
                    list.add(nums1[i]);
                }
                i++; j++;
            } else if (nums1[i] < nums2[j]) {
                i++;
            } else {
                j++;
            }
        }
        int[] res = new int[list.size()];
        for (int k = 0; k < list.size(); k++) res[k] = list.get(k);
        return res;
    }
}
```

â± **Time Complexity:** O(m log m + n log n)
ğŸ’¾ **Space Complexity:** O(1) (ignoring output)

---

#### ğŸŸ¢ Solution 4 â€” Boolean Bitmap (using constraints âš¡)

```java
import java.util.ArrayList;

public class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        boolean[] seen1 = new boolean[1001];
        boolean[] used = new boolean[1001];
        for (int v : nums1) seen1[v] = true;

        ArrayList<Integer> list = new ArrayList<>();
        for (int v : nums2) {
            if (seen1[v] && !used[v]) {
                list.add(v);
                used[v] = true;
            }
        }

        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) res[i] = list.get(i);
        return res;
    }
}
```

â± **Time Complexity:** O(m + n)
ğŸ’¾ **Space Complexity:** O(1) (fixed 1001-size arrays)

---

### **Approach ğŸ› ï¸**

* **Brute Force ğŸ”´** â†’ Check each element of `nums1` against `nums2`, store matches in a set.
* **HashSet ğŸŸ¡** â†’ Put one array into a set, check elements of the other, store common in a result set.
* **Sorting + Two Pointers ğŸ”µ** â†’ Sort both arrays and use two pointers to find common elements, skip duplicates.
* **Bitmap ğŸŸ¢** â†’ Use boolean arrays since values are in range \[0..1000], mark presence and avoid duplicates.

---

### **Intuition ğŸ’­**

* Intersection means elements **present in both arrays**, once only.
* **Set** naturally models uniqueness â†’ ideal for this problem.
* **Sorting** aligns duplicates â†’ easy to scan linearly.
* **Bitmap** leverages constraints â†’ ultra-fast and constant memory.

---

ğŸ‘‰ Recommended: **Solution 2 (HashSet) ğŸŸ¡** â†’ simple + efficient for general use.