### **Question**

Given a non-empty array of integers nums, every element appears **twice** except for **one**. Find that single one.

You must implement a solution with **linear runtime O(n) ⏱** and **constant extra space O(1) 💾**.

**Example 1:**
👉 Input: nums = \[2,2,1]
✅ Output: 1

**Example 2:**
👉 Input: nums = \[4,1,2,1,2]
✅ Output: 4

**Example 3:**
👉 Input: nums = \[1]
✅ Output: 1

**Constraints:**

* 1 <= nums.length <= 3 × 10⁴
* -3 × 10⁴ <= nums\[i] <= 3 × 10⁴
* Every element appears **twice** except for one element.

---

### **Solution 1: HashSet ✅ (Easy but uses extra space)**

```java
import java.util.HashSet;

public class Solution {
    public int singleNumber(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                set.remove(num);
            } else {
                set.add(num);
            }
        }
        return set.iterator().next();
    }
}
```

**Approach:** Add elements to set, remove if duplicate.
**Intuition:** Only unique element will remain in set.
**⏱ Time Complexity:** O(n)
**💾 Space Complexity:** O(n) (❌ not constant space)

---

### **Solution 2: Bit Manipulation (XOR) ⚡ (Optimal)**

```java
public class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;   // XOR operation
        }
        return result;
    }
}
```

**Approach:**

* Use XOR (`^`) property:

  * `a ^ a = 0`
  * `a ^ 0 = a`
* All duplicate pairs cancel out to `0`, leaving the single number.

**Intuition:**
XOR “cancels” out duplicates automatically, so only the unique number remains.

**⏱ Time Complexity:** O(n)
**💾 Space Complexity:** O(1) ✅

---

👉 **Recommended:** Solution 2 (XOR) ⚡ → Best choice (linear time + constant space).