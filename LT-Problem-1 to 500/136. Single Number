### **Question**

Given a non-empty array of integers nums, every element appears **twice** except for **one**. Find that single one.

You must implement a solution with **linear runtime O(n) â±** and **constant extra space O(1) ğŸ’¾**.

**Example 1:**
ğŸ‘‰ Input: nums = \[2,2,1]
âœ… Output: 1

**Example 2:**
ğŸ‘‰ Input: nums = \[4,1,2,1,2]
âœ… Output: 4

**Example 3:**
ğŸ‘‰ Input: nums = \[1]
âœ… Output: 1

**Constraints:**

* 1 <= nums.length <= 3 Ã— 10â´
* -3 Ã— 10â´ <= nums\[i] <= 3 Ã— 10â´
* Every element appears **twice** except for one element.

---

### **Solution 1: HashSet âœ… (Easy but uses extra space)**

```java
import java.util.HashSet;

public class Solution {
    public int singleNumber(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for (int num : nums) {
            if (set.contains(num)) {
                set.remove(num);
            } else {
                set.add(num);
            }
        }
        return set.iterator().next();
    }
}
```

**Approach:** Add elements to set, remove if duplicate.
**Intuition:** Only unique element will remain in set.
**â± Time Complexity:** O(n)
**ğŸ’¾ Space Complexity:** O(n) (âŒ not constant space)

---

### **Solution 2: Bit Manipulation (XOR) âš¡ (Optimal)**

```java
public class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;   // XOR operation
        }
        return result;
    }
}
```

**Approach:**

* Use XOR (`^`) property:

  * `a ^ a = 0`
  * `a ^ 0 = a`
* All duplicate pairs cancel out to `0`, leaving the single number.

**Intuition:**
XOR â€œcancelsâ€ out duplicates automatically, so only the unique number remains.

**â± Time Complexity:** O(n)
**ğŸ’¾ Space Complexity:** O(1) âœ…

---

ğŸ‘‰ **Recommended:** Solution 2 (XOR) âš¡ â†’ Best choice (linear time + constant space).