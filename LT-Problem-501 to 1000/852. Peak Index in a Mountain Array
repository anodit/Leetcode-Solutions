852. Peak Index in a Mountain Array â€” cheat-sheet with Java solutions ğŸ”ï¸
Problem (short)

Given a mountain array arr (strictly increasing then strictly decreasing, length â‰¥ 3), return the index of the peak element (the maximum).
Examples:

arr = [0,1,0] â†’ output 1.

arr = [0,2,1,0] â†’ output 1.

arr = [3,4,5,1] â†’ output 2.

Approach & Intuition ğŸ’¡

A mountain array has exactly one peak: values strictly rise to the peak then strictly fall.

Brute force: scan the array and track the index of the maximum element (O(n)). Simple and safe.

Binary search (optimal): use the property that if arr[mid] < arr[mid+1], you're on the rising slope â†’ peak is to the right; otherwise you're on the falling slope or at the peak â†’ peak is at mid or to the left. This gives O(log n).

Solutions (Java)
1) Brute-force â€” O(n) time, O(1) space âœ…

Simple scan for maximum index.

// Brute-force: find index of max element
public class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int peakIdx = 0;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > arr[peakIdx]) {
                peakIdx = i;
            }
        }
        return peakIdx;
    }
}


Complexity: Time O(n), Space O(1).
Good when n is small or simplicity is preferred. ğŸ‘

2) Binary Search â€” O(log n) time, O(1) space â­ (preferred)

Binary-search on the slope direction using arr[mid] vs arr[mid+1].

// Binary search: O(log n)
public class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int low = 0;
        int high = arr.length - 1;
        while (low < high) {
            int mid = low + (high - low) / 2;
            // if mid is on the rising slope, move right
            if (arr[mid] < arr[mid + 1]) {
                low = mid + 1;
            } else {
                // mid might be the peak or on the falling slope
                high = mid;
            }
        }
        // low == high == peak index
        return low;
    }
}


Why it works: At each step we discard half the array by checking slope direction. Eventually low == high at the peak. ğŸš€
Complexity: Time O(log n), Space O(1).

3) Two-pointer / Slight variation â€” O(n) worst-case (not recommended)

You could advance from left while arr[i] < arr[i+1] and stop â€” this is similar to linear scan and O(n). Not an improvement, but compact:

public class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int i = 0;
        while (arr[i] < arr[i + 1]) i++;
        return i;
    }
}


Complexity: O(n), Space O(1). Works because input is guaranteed to be a mountain array.

Edge cases & notes âš ï¸

Input guarantee (LeetCode): array is a valid mountain array (so arr[mid+1] access in binary search is safe when mid in range).

Always ensure mid+1 index exists â€” but in the binary-search loop we maintain low < high, so mid < high and mid+1 safe.

If the input could be invalid in your context, validate before using these methods.