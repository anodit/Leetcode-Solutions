❓ Question

You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.

👉 Your solution must run in O(log n) time and O(1) space.

Example 1

Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2

Example 2

Input: nums = [3,3,7,7,10,11,11]
Output: 10

Constraints

1 <= nums.length <= 10^5

0 <= nums[i] <= 10^5

💡 Solutions
🥉 Brute Force (O(n))
class Solution {
    public int singleNonDuplicate(int[] nums) {
        for (int i = 0; i < nums.length; i += 2) {
            // if last element or mismatch found
            if (i == nums.length - 1 || nums[i] != nums[i + 1]) {
                return nums[i];
            }
        }
        return -1; // not expected
    }
}

🥈 Better (O(n), XOR Trick)

👉 Property: x ^ x = 0 and x ^ 0 = x.
So XOR of all elements will cancel out duplicates and leave single element.

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
}

🥇 Optimal (O(log n), Binary Search)

👉 Since array is sorted, we can use binary search.

class Solution {
    public int singleNonDuplicate(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            // Ensure mid is even (start of a pair)
            if (mid % 2 == 1) mid--;
            
            if (nums[mid] == nums[mid + 1]) {
                // Single element is on the right side
                left = mid + 2;
            } else {
                // Single element is on the left side (including mid)
                right = mid;
            }
        }
        return nums[left];
    }
}

🔎 Approach

Brute Force: Traverse array in steps of 2, check if pairs are equal.

XOR Trick: Cancel out pairs using XOR, left element is answer.

Binary Search (Optimal):

Array is sorted, so pairs appear as (even, odd) indices.

If mismatch happens, single element lies on the left side.

Otherwise, continue on the right side.

Narrow down to single element in O(log n).

🤔 Intuition

Since array is sorted, duplicates always appear in pairs before the single element.

After the single element, pairing gets shifted (odd-even mismatched).

Using binary search, we keep cutting the search space in half until only the single element remains.

That’s why O(log n) with O(1) space is possible.